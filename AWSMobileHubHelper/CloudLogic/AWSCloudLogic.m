//
//  AWSCloudLogic.m
//
// Copyright 2016 Amazon.com, Inc. or its affiliates (Amazon). All Rights Reserved.
//
// Code generated by AWS Mobile Hub. Amazon gives unlimited permission to
// copy, distribute and modify it.
//

#import <Foundation/Foundation.h>
#import "AWSCloudLogic.h"
#import <AWSLambda/AWSLambda.h>

@interface AWSCloudLogic ()

@property AWSLambdaInvoker *invoker;

@end

@interface AWSLambdaInvoker()

- (instancetype)initWithConfiguration:(AWSServiceConfiguration *)configuration;

@end

@implementation AWSCloudLogic

static NSString *const AWSInfoClougLogic = @"CloudLogic";
static AWSSynchronizedMutableDictionary *_serviceClients = nil;

+ (instancetype)defaultCloudLogic {
    AWSServiceConfiguration *serviceConfiguration = nil;
    AWSServiceInfo *serviceInfo = [[AWSInfo defaultAWSInfo] defaultServiceInfo:AWSInfoClougLogic];
    if (serviceInfo) {
        serviceConfiguration = [[AWSServiceConfiguration alloc] initWithRegion:serviceInfo.region
                                                           credentialsProvider:serviceInfo.cognitoCredentialsProvider];
    }
    
    if (!serviceConfiguration) {
        serviceConfiguration = [AWSServiceManager defaultServiceManager].defaultServiceConfiguration;
    }
    
    static AWSCloudLogic *_defaultCloudLogic = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _defaultCloudLogic = [[AWSCloudLogic alloc] initWithConfiguration:serviceConfiguration
                                                                      key:@"default"];
    });
    
    return _defaultCloudLogic;
}

- (instancetype)initWithConfiguration:(AWSServiceConfiguration *)configuration
                                  key:(NSString *)key {
    if (self = [super init]) {
        _invoker = [[AWSLambdaInvoker alloc] initWithConfiguration:configuration];
    }
    return self;
}


+ (void)registerCloudLogicWithConfiguration:(AWSServiceConfiguration *)serviceConfiguration
                                     forKey:(NSString *)key {
    if ([key isEqualToString:AWSInfoDefault]) {
        @throw [NSException exceptionWithName:NSInternalInconsistencyException
                                       reason:@"The key used for registering this instance is a reserved key. Please use some other key to register the instance."
                                     userInfo:nil];
    }
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _serviceClients = [AWSSynchronizedMutableDictionary new];
    });
    
    [_serviceClients setObject:[[AWSCloudLogic alloc] initWithConfiguration:serviceConfiguration
                                                                        key:key]
                        forKey:key];
    
}

+ (instancetype)CloudLogicForKey:(NSString *)key {
    @synchronized(self) {
        AWSCloudLogic *serviceClient = [_serviceClients objectForKey:key];
        if (serviceClient) {
            return serviceClient;
        }
        
        AWSServiceInfo *serviceInfo = [[AWSInfo defaultAWSInfo] serviceInfo:AWSInfoClougLogic
                                                                     forKey:key];
        if (serviceInfo) {
            AWSServiceConfiguration *serviceConfiguration = [[AWSServiceConfiguration alloc] initWithRegion:serviceInfo.region
                                                                                        credentialsProvider:serviceInfo.cognitoCredentialsProvider];
            [AWSCloudLogic registerCloudLogicWithConfiguration:serviceConfiguration
                                                        forKey:key];
        }
        
        return [_serviceClients objectForKey:key];
    }
}

+ (void)removeCloudLogicForKey:(NSString *)key {
    [_serviceClients removeObjectForKey:key];
}

- (void)invokeFunction:(NSString *)name
        withParameters:(id)parameters
       completionBlock:(void (^)(id result, NSError *error))completionBlock {
    AWSLogDebug(@"invokeFunction: Function Name: %@", name);
    [_invoker invokeFunction:name
                  JSONObject:parameters
           completionHandler:^(id _Nullable response, NSError * _Nullable error) {
               if (completionBlock) {
                   completionBlock(response, error);
               }
           }];
}

@end
